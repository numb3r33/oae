# AUTOGENERATED! DO NOT EDIT! File to edit: 01_Representation.ipynb (unless otherwise specified).

__all__ = ['SEED', 'ATMSKLEARN', 'Instance', 'ATMSKLEARN', 'combine', 'Instance']

# Cell
import re
import IPython, graphviz

import numpy as np
import pandas as pd

from sklearn.ensemble import RandomForestClassifier, RandomForestRegressor
from sklearn.tree import export_graphviz

from .core import *

SEED = 41
np.random.seed(SEED)

# Cell
class ATMSKLEARN:
    def __init__(self, trained_model, X):
        self.trained_model = trained_model
        self.X = X

        self.check_tree_with_no_leaves()

    def check_tree_with_no_leaves(self):
        for tidx, t in enumerate(self.get_trees()):
            if len(t.tree_.feature) < 0: raise ValueError(f'Tree: {tidx} has no leaves.')

    def get_trees(self):
        return self.trained_model.estimators_

    @property
    def num_trees(self):
        return len(self.get_trees())

    def calculate_tree_weights(self):
        T = self.num_trees
        return np.ones(shape=(T, )) / T

    def get_leaves(self, tree):
        return np.where(tree.feature < 0)[0]

    def get_leaves_value(self, tree, leaves):
        return np.array([tree.value[l] for l in leaves])

    def get_node_threshold(self, tree, fidx):
        idx = np.where(tree.feature == fidx)[0]
        return list(tree.threshold[idx]) if len(idx) > 0 else []

    def make_partitions_num(self, splits, INF=1e8):
        splits = np.insert(splits, 0, -INF)
        splits = np.insert(splits, len(splits), INF)

        partitions = []
        for i in range(len(splits) - 1):
            partitions.append([splits[i], splits[i+1]])

        return partitions

    def make_partitions_cat(self, splits):
        max_val = splits[-1] + 1
        splits  = np.insert(splits, len(splits), max_val)

        partitions = []
        for i in range(len(splits) - 1):
            partitions.append([splits[i], splits[i+1]])
        return partitions

    def h_k(self, tree, combine, class_):
        leaves = self.get_leaves(tree)
        leaves_value = self.get_leaves_value(tree, leaves)
        return combine(leaves_value, class_)

    def h_t_k(self, combine, class_=None):
        return [self.h_k(tree.tree_, combine, class_) for tree in self.get_trees()]

    def phi_k(self, tree, x):
        leaves = self.get_leaves(tree)
        return [tree.decision_path(x.astype(np.float32)).toarray().ravel()[leaf] for leaf in leaves]

    def phi_t_k(self, x):
        return [self.phi_k(tree.tree_, x) for tree in self.get_trees()]

    def feature_partitions_cat(self, fidx):
        splits  = np.sort(np.unique(self.X[:, fidx]))
        return self.make_partitions_cat(splits)

    def feature_partitions_num(self, fidx):
        splits = np.hstack([self.get_node_threshold(tree.tree_, fidx) for tree in self.get_trees()])
        splits = np.sort(np.unique(splits))
        return self.make_partitions_num(splits)

    def v_j(self, fidx, ftype):
        if ftype == 'categorical': return self.feature_partitions_cat(fidx)
        else: return self.feature_partitions_num(fidx)

    def v_i_j(self, feature):
        fdtypes = feature.dtypes
        feat    = feature.content
        return [self.v_j(i, fdtypes[i]) for i in range(len(fdtypes))]

    def v_j_mask(self, partition, fval, ftype):
        mask = []

        for s in partition:
            if ftype == 'numerical':
                if (fval > s[0]) and (fval <= s[1]):
                    mask.append(1)
                else:
                    mask.append(0)
            else:
                if (fval >= s[0]) and (fval < s[1]):
                    mask.append(1)
                else:
                    mask.append(0)

        return mask

    def v_i_j_mask(self, partitions, feature):
        return [self.v_j_mask(partitions[i], feature.content[i], feature.types[i]) for i in range(len(partitions))]

    def mask_v_j(self, mask, partition):
        return [partition[midx] for midx, m in enumerate(mask) if m]

    def masks_v_i_j(self, masks, partitions):
        return [self.mask_v_j(masks[i], partitions[i]) for i in range(len(partitions))]


    def suggest_changes(self, sol_mask, feature):
        partitions = self.v_i_j(feature)
        orig_mask  = self.v_i_j_mask(partitions, feature)

        changes = []
        for i in range(len(sol_mask)):
            if sol_mask[i] == orig_mask[i]:
                changes.append(f'no change, current value: {feature.content[i]}')
            else:
                sol_mask_one_idx  = np.where(np.array(sol_mask[i]) == 1)[0][0]
                changes.append(f'current value: {feature.content[i]}, proposed change: {partitions[i][sol_mask_one_idx]}')

        return changes

    def transform(self, sol_mask, feature):
        partitions = self.v_i_j(feature)
        orig_mask  = self.v_i_j_mask(partitions, feature)

        fnames = feature.fnames
        dtypes = feature.types

        transformed_feature = []

        for i in range(len(sol_mask)):
            if sol_mask[i] == orig_mask[i]:
                transformed_feature.append(feature.content[i])
            else:
                sol_mask_one_idx  = np.where(np.array(sol_mask[i]) == 1)[0][0]
                if dtypes[i] == 'numerical':
                    if i <= len(dtypes) - 1:
                        transformed_feature.append(partitions[i][sol_mask_one_idx][1])
                    else:
                        diff = partitions[i][sol_mask_one_idx][1] - partitions[i][sol_mask_one_idx][0]
                        scaled_diff = diff * 0.1
                        transformed_feature.append(np.random.uniform(partitions[i][sol_mask_one_idx][0] + scaled_diff,
                                                                 partitions[i][sol_mask_one_idx][1]
                                                                ))

                else:
                    transformed_feature.append(partitions[i][sol_mask_one_idx][0])

        return pd.DataFrame(np.array(transformed_feature).reshape(1, -1), columns=fnames)

    def find_ancestors(self, tree, node, leaf_node, p):
        if node == leaf_node: return [True, p]
        if tree.feature[node] < 0:
            p.pop()
            return [False, p]

        in_left_branch, p = (self.find_ancestors(tree, tree.children_left[node], leaf_node, p + [(node, 'left')]))
        if in_left_branch: return [True, p]

        in_right_branch, p = (self.find_ancestors(tree, tree.children_right[node], leaf_node, p + [(node, 'right')]))
        if in_right_branch: return [True, p]

        p.pop()
        return [False, p]

    def pi_k(self, tree):
        leaves = self.get_leaves(tree)
        root_index = 0
        return {kidx:self.find_ancestors(tree, node=root_index, leaf_node=k, p=[])[1] for kidx, k in enumerate(leaves)}

    def pi_t_k(self):
        trees = self.get_trees()
        return [self.pi_k(tree.tree_) for tree in trees]

    def predicate_mask(self, tree, fname, fidx, branch, v_i_j, dtype):
        threshold = tree.threshold[fidx]
        filter_predicates = []

        if branch == 'left':
            for p in v_i_j[fname]:
                if dtype == 'numerical':
                    if p[len(p) - 1] <= threshold:
                        filter_predicates.append(1)
                    else:
                        filter_predicates.append(0)
                else:
                    if p[len(p) - 1] < threshold:
                        filter_predicates.append(1)
                    else:
                        if (p[0] <= threshold):
                            filter_predicates.append(1)
                        else:
                            filter_predicates.append(0)
        else:
            for p in v_i_j[fname]:
                if dtype == 'numerical':
                    if p[0] >= threshold:
                        filter_predicates.append(1)
                    else:
                        filter_predicates.append(0)
                else:
                    if p[0] > threshold:
                        filter_predicates.append(1)
                    else:
                        filter_predicates.append(0)

        return filter_predicates

    def predicates_mask(self, tree, ancestor, v_i_j, dtypes):
        p, p_branch = ancestor
        fname = tree.feature[p]
        dtype = dtypes[fname]
        return self.predicate_mask(tree, fname, p, p_branch, v_i_j, dtype)

# Cell
def combine(leaves_value, class_):
    if class_ is None: class_ = 1
    return [(c.ravel() / c.ravel().sum())[class_] for c in leaves_value]

# Cell
class Instance:
    def __init__(self, x, dtypes):
        if len(dtypes) == 0: raise ValueError('Data type list cannot be empty')

        if isinstance(x, pd.Series): self.content = x.values
        else: self.content = np.array(x)

        if isinstance(x, pd.Series): self.feat_names = x.index.tolist()
        else: self.feat_names = [f'f_{i}' for i in range(len(x))]

        self.types = dtypes

    @property
    def value(self): return self.content
    @property
    def dtypes(self): return self.types
    @property
    def fnames(self): return self.feat_names